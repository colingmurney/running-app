{"ast":null,"code":"/* jshint node:true */\n'use strict';\n\nconst helper = require('../core/helper');\n\nclass Handler {\n  constructor(options) {\n    this._options = options; // an object of {typeName:(value,index,parent)=>any}\n\n    this._options.typeHandlers = this._options.typeHandlers || {};\n  }\n  /**\n   * Check if results needing mapping to alternate value\n   *\n   * @returns [{item, value}] result\n   */\n\n\n  _setHeaders(result, item) {\n    let self = this;\n    if (!item) return result;\n    return result.map(function (element) {\n      element.item = element.item ? item + self._options.headerPathString + element.item : item;\n      return element;\n    });\n  }\n\n  castValue(element, item, index, parent) {\n    //cast by matching constructor\n    const types = this._options.typeHandlers;\n\n    for (let type in types) {\n      if (isInstanceOfTypeName(element, type)) {\n        element = types[type].call(types, element, index, parent);\n        break; //first match we move on\n      }\n    }\n\n    return element;\n  }\n\n  checkComplex(element, item) {\n    //Check if element is a Date\n    if (helper.isDate(element)) {\n      return [{\n        item: item,\n        value: this._options.handleDate(element, item)\n      }];\n    } //Check if element is an Array\n    else if (helper.isArray(element)) {\n        var resultArray = this._handleArray(element, item);\n\n        return this._setHeaders(resultArray, item);\n      } //Check if element is a Object\n      else if (helper.isObject(element)) {\n          var resultObject = this._handleObject(element);\n\n          return this._setHeaders(resultObject, item);\n        }\n\n    return [{\n      item: item,\n      value: ''\n    }];\n  }\n  /**\n   * Check the element type of the element call the correct handle function\n   *\n   * @param element Element that will be checked\n   * @param item Used to make the headers/path breadcrumb\n   * @returns [{item, value}] result\n   */\n\n\n  check(element, item, index, parent) {\n    element = this.castValue(element, item, index, parent); // try simple value by highier performance switch\n\n    switch (typeof element) {\n      case 'string':\n        return [{\n          item: item,\n          value: this._handleString(element, item)\n        }];\n\n      case 'number':\n        return [{\n          item: item,\n          value: this._handleNumber(element, item)\n        }];\n\n      case 'boolean':\n        return [{\n          item: item,\n          value: this._handleBoolean.bind(this)(element, item)\n        }];\n    }\n\n    return this.checkComplex(element, item);\n  }\n  /**\n   * Handle all Objects\n   *\n   * @param {Object} obj\n   * @returns [{item, value}] result\n   */\n\n\n  _handleObject(obj) {\n    var result = []; //Look every object props\n\n    for (var prop in obj) {\n      var propData = obj[prop]; //Check the propData type\n\n      var resultCheckType = this.check(propData, prop, prop, obj); //Append to results aka merge results aka array-append-array\n\n      result = result.concat(resultCheckType);\n    }\n\n    return result;\n  }\n  /**\n   * Handle all Arrays, merges arrays with primitive types in a single value\n   *\n   * @param {Array} array\n   * @returns [{item, value}] result\n   */\n\n\n  _handleArray(array) {\n    let self = this;\n    let result = [];\n    var firstElementWithoutItem;\n\n    for (let aIndex = 0; aIndex < array.length; ++aIndex) {\n      let element = array[aIndex]; //Check the propData type\n\n      var resultCheckType = self.check(element, null, aIndex, array); //Check for results without itens, merge all itens with the first occurrence\n\n      if (resultCheckType.length === 0) continue;\n      var firstResult = resultCheckType[0];\n\n      if (!firstResult.item && firstElementWithoutItem !== undefined) {\n        firstElementWithoutItem.value += self._options.arrayPathString + firstResult.value;\n        continue;\n      } else if (resultCheckType.length > 0 && !firstResult.item && firstElementWithoutItem === undefined) {\n        firstElementWithoutItem = firstResult;\n      } //Append to results\n\n\n      result = result.concat(resultCheckType);\n    }\n\n    return result;\n  }\n  /**\n   * Handle all Boolean variables, can be replaced with options.handleBoolean\n   *\n   * @param {Boolean} boolean\n   * @returns {String} result\n   */\n\n\n  _handleBoolean(boolean) {\n    var result; //Check for booolean options\n\n    if (boolean) {\n      result = this._options.booleanTrueString || 'true';\n    } else {\n      result = this._options.booleanFalseString || 'false';\n    }\n\n    return result;\n  }\n  /**\n   * Handle all String variables, can be replaced with options.handleString\n   *\n   * @param {String} string\n   * @returns {String} string\n   */\n\n\n  _handleString(string) {\n    return string;\n  }\n  /**\n   * Handle all Number variables, can be replaced with options.handleNumber\n   *\n   * @param {Number} number\n   * @returns {Number} number\n   */\n\n\n  _handleNumber(number) {\n    return number;\n  }\n  /**\n   * Handle all Date variables, can be replaced with options.handleDate\n   *\n   * @param {Date} number\n   * @returns {string} result\n   */\n\n\n  _handleDate(date) {\n    return date.toLocaleDateString();\n  }\n\n}\n\nmodule.exports = Handler;\nconst globalScope = typeof window === \"undefined\" ? global : window;\n\nfunction isInstanceOfTypeName(element, typeName) {\n  if (element instanceof globalScope[typeName]) {\n    return true; //Buffer and complex objects\n  } //literals in javascript cannot be checked by instance of\n\n\n  switch (typeof element) {\n    case 'string':\n      return typeName === \"String\";\n\n    case 'boolean':\n      return typeName === \"Boolean\";\n\n    case 'number':\n      return typeName === \"Number\";\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/colin/Desktop/GitHub/running-app/client/node_modules/jsonexport/lib/parser/handler.js"],"names":["helper","require","Handler","constructor","options","_options","typeHandlers","_setHeaders","result","item","self","map","element","headerPathString","castValue","index","parent","types","type","isInstanceOfTypeName","call","checkComplex","isDate","value","handleDate","isArray","resultArray","_handleArray","isObject","resultObject","_handleObject","check","_handleString","_handleNumber","_handleBoolean","bind","obj","prop","propData","resultCheckType","concat","array","firstElementWithoutItem","aIndex","length","firstResult","undefined","arrayPathString","boolean","booleanTrueString","booleanFalseString","string","number","_handleDate","date","toLocaleDateString","module","exports","globalScope","window","global","typeName"],"mappings":"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","sourcesContent":["/* jshint node:true */\n'use strict';\n\nconst helper = require('../core/helper');\n\nclass Handler {\n  constructor(options) {\n    this._options = options;\n\n    // an object of {typeName:(value,index,parent)=>any}\n    this._options.typeHandlers = this._options.typeHandlers || {};\n  }\n\n  /**\n   * Check if results needing mapping to alternate value\n   *\n   * @returns [{item, value}] result\n   */\n  _setHeaders(result, item) {\n    let self = this;\n    if (!item) return result;\n    return result.map(function(element) {\n      element.item = element.item ? item + self._options.headerPathString + element.item : item;\n      return element;\n    });\n  }\n\n  castValue(element, item, index, parent){\n    //cast by matching constructor\n    const types = this._options.typeHandlers;\n    for (let type in types ) {\n      if( isInstanceOfTypeName(element,type) ){\n        element = types[type].call(types, element, index, parent);\n        break;//first match we move on\n      }\n    }\n\n    return element;\n  }\n\n  checkComplex(element, item){\n    //Check if element is a Date\n    if (helper.isDate(element)) {\n      return [{\n        item: item,\n        value: this._options.handleDate(element, item),\n      }];\n    }\n    //Check if element is an Array\n    else if (helper.isArray(element)) {\n      var resultArray = this._handleArray(element, item);\n      return this._setHeaders(resultArray, item);\n    }\n    //Check if element is a Object\n    else if (helper.isObject(element)) {\n      var resultObject = this._handleObject(element);\n      return this._setHeaders(resultObject, item);\n    }\n\n    return [{\n      item: item,\n      value: '',\n    }];\n  }\n  \n  /**\n   * Check the element type of the element call the correct handle function\n   *\n   * @param element Element that will be checked\n   * @param item Used to make the headers/path breadcrumb\n   * @returns [{item, value}] result\n   */\n  check(element, item, index, parent) {\n    element = this.castValue(element, item, index, parent);\n    // try simple value by highier performance switch\n    switch(typeof element){\n      case 'string':\n        return [{\n          item: item,\n          value: this._handleString(element, item),\n        }];\n\n      case 'number':\n        return [{\n          item: item,\n          value: this._handleNumber(element, item),\n        }];\n\n      case 'boolean':\n        return [{\n          item: item,\n          value: this._handleBoolean.bind(this)(element, item),\n        }];\n    }\n\n    return this.checkComplex(element, item);\n  }\n\n\n  /**\n   * Handle all Objects\n   *\n   * @param {Object} obj\n   * @returns [{item, value}] result\n   */\n  _handleObject(obj) {\n    var result = [];\n    //Look every object props\n    for (var prop in obj) {\n      var propData = obj[prop];\n      //Check the propData type\n      var resultCheckType = this.check(propData, prop, prop, obj);\n      //Append to results aka merge results aka array-append-array\n      result = result.concat(resultCheckType);\n    }\n    return result;\n  }\n  \n  /**\n   * Handle all Arrays, merges arrays with primitive types in a single value\n   *\n   * @param {Array} array\n   * @returns [{item, value}] result\n   */\n  _handleArray(array) {\n    let self = this;\n    let result = [];\n    var firstElementWithoutItem;\n    for (let aIndex=0; aIndex < array.length; ++aIndex) {\n      let element = array[aIndex];\n      //Check the propData type\n      var resultCheckType = self.check(element, null, aIndex, array);\n      //Check for results without itens, merge all itens with the first occurrence\n      if (resultCheckType.length === 0) continue;\n      var firstResult = resultCheckType[0];\n      if (!firstResult.item && firstElementWithoutItem !== undefined) {\n        firstElementWithoutItem.value += self._options.arrayPathString + firstResult.value;\n        continue;\n      } else if (resultCheckType.length > 0 && !firstResult.item && firstElementWithoutItem === undefined) {\n        firstElementWithoutItem = firstResult;\n      }\n      //Append to results\n      result = result.concat(resultCheckType);\n    }\n    return result;\n  }\n  /**\n   * Handle all Boolean variables, can be replaced with options.handleBoolean\n   *\n   * @param {Boolean} boolean\n   * @returns {String} result\n   */\n  _handleBoolean(boolean) {\n    var result;\n    //Check for booolean options\n    if (boolean) {\n      result = this._options.booleanTrueString || 'true';\n    } else {\n      result = this._options.booleanFalseString || 'false';\n    }\n    return result;\n  }\n  /**\n   * Handle all String variables, can be replaced with options.handleString\n   *\n   * @param {String} string\n   * @returns {String} string\n   */\n  _handleString(string) {\n    return string;\n  }\n  /**\n   * Handle all Number variables, can be replaced with options.handleNumber\n   *\n   * @param {Number} number\n   * @returns {Number} number\n   */\n  _handleNumber(number) {\n    return number;\n  }\n  /**\n   * Handle all Date variables, can be replaced with options.handleDate\n   *\n   * @param {Date} number\n   * @returns {string} result\n   */\n  _handleDate(date) {\n    return date.toLocaleDateString();\n  }\n\n}\n\nmodule.exports = Handler;\n\nconst globalScope = typeof(window)===\"undefined\" ? global : window;\nfunction isInstanceOfTypeName(element, typeName){\n  if( element instanceof globalScope[typeName] ){\n    return true;//Buffer and complex objects\n  }\n\n  //literals in javascript cannot be checked by instance of\n  switch( typeof(element) ){\n    case 'string':return typeName===\"String\";\n    case 'boolean':return typeName===\"Boolean\";\n    case 'number':return typeName===\"Number\";\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}