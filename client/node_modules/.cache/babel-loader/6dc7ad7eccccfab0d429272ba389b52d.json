{"ast":null,"code":"/* jshint node:true */\n'use strict';\n/**\n * Module dependencies.\n */\n\nconst joinRows = require('../core/join-rows');\n\nconst Handler = require('./handler');\n\nconst helper = require('../core/helper');\n\nclass Parser {\n  constructor(options) {\n    this._options = options || {};\n    this._handler = new Handler(this._options);\n    this._headers = this._options.headers || [];\n    this._escape = require('../core/escape-delimiters')(this._options.textDelimiter, this._options.rowDelimiter, this._options.forceTextDelimiter);\n  }\n  /**\n   * Generates a CSV file with optional headers based on the passed JSON,\n   * with can be an Object or Array.\n   *\n   * @param {Object|Array} json\n   * @param {Function} done(err,csv) - Callback function\n   *      if error, returning error in call back.\n   *      if csv is created successfully, returning csv output to callback.\n   */\n\n\n  parse(json, done, stream) {\n    if (helper.isArray(json)) return done(null, this._parseArray(json, stream));else if (helper.isObject(json)) return done(null, this._parseObject(json));\n    return done(new Error('Unable to parse the JSON object, its not an Array or Object.'));\n  }\n\n  get headers() {\n    let headers = this._headers;\n    if (this._options.rename && this._options.rename.length > 0) headers = headers.map(header => this._options.rename[this._options.headers.indexOf(header)] || header);\n\n    if (this._options.forceTextDelimiter) {\n      headers = headers.map(header => {\n        return `${this._options.textDelimiter}${header}${this._options.textDelimiter}`;\n      });\n    }\n\n    if (this._options.mapHeaders) headers = headers.map(this._options.mapHeaders);\n    return headers.join(this._options.rowDelimiter);\n  }\n\n  _checkRows(rows) {\n    let lastRow = null;\n    let finalRows = [];\n\n    let fillGaps = (col, index) => col === '' || col === undefined ? lastRow[index] : col;\n\n    for (let row of rows) {\n      let missing = this._headers.length - row.length;\n      if (missing > 0) row = row.concat(Array(missing).join(\".\").split(\".\"));\n      if (lastRow && this._options.fillGaps) row = row.map(fillGaps);\n      finalRows.push(row.join(this._options.rowDelimiter));\n      lastRow = row;\n    }\n\n    return finalRows;\n  }\n\n  _parseArray(json, stream) {\n    let self = this;\n    this._headers = this._headers || [];\n    let fileRows = [];\n    let outputFile;\n    let fillRows;\n\n    let getHeaderIndex = function (header) {\n      var index = self._headers.indexOf(header);\n\n      if (index === -1) {\n        self._headers.push(header);\n\n        index = self._headers.indexOf(header);\n      }\n\n      return index;\n    }; //Generate the csv output\n\n\n    fillRows = function (result) {\n      const rows = [];\n\n      const fillAndPush = row => rows.push(row.map(col => col != null ? col : '')); // initialize the array with empty strings to handle 'unpopular' headers\n\n\n      const newRow = () => new Array(self._headers.length).fill(null);\n\n      const emptyRowIndexByHeader = {};\n      let currentRow = newRow();\n\n      for (let element of result) {\n        let elementHeaderIndex = getHeaderIndex(element.item);\n\n        if (currentRow[elementHeaderIndex] != undefined) {\n          fillAndPush(currentRow);\n          currentRow = newRow();\n        }\n\n        emptyRowIndexByHeader[elementHeaderIndex] = emptyRowIndexByHeader[elementHeaderIndex] || 0; // make sure there isnt a empty row for this header\n\n        if (self._options.fillTopRow && emptyRowIndexByHeader[elementHeaderIndex] < rows.length) {\n          rows[emptyRowIndexByHeader[elementHeaderIndex]][elementHeaderIndex] = self._escape(element.value);\n          emptyRowIndexByHeader[elementHeaderIndex] += 1;\n          continue;\n        }\n\n        currentRow[elementHeaderIndex] = self._escape(element.value);\n        emptyRowIndexByHeader[elementHeaderIndex] += 1;\n      } // push last row\n\n\n      if (currentRow.length > 0) {\n        fillAndPush(currentRow);\n      }\n\n      fileRows = fileRows.concat(self._checkRows(rows));\n    };\n\n    for (let item of json) {\n      //Call checkType to list all items inside this object\n      //Items are returned as a object {item: 'Prop Value, Item Name', value: 'Prop Data Value'}\n      let itemResult = self._handler.check(item, self._options.mainPathItem, item, json);\n\n      fillRows(itemResult);\n    }\n\n    if (!stream && self._options.includeHeaders) {\n      //Add the headers to the first line\n      fileRows.unshift(this.headers);\n    }\n\n    return joinRows(fileRows, self._options.endOfLine);\n  }\n\n  _parseObject(json) {\n    let self = this;\n    let fileRows = [];\n    let parseResult = [];\n    let outputFile;\n    let fillRows;\n    let horizontalRows = [[], []];\n\n    fillRows = function (result) {\n      var value = result.value ? result.value.toString() : self._options.undefinedString;\n      value = self._escape(value); //Type header;value\n\n      if (self._options.verticalOutput) {\n        var row = [result.item, value];\n        fileRows.push(row.join(self._options.rowDelimiter));\n      } else {\n        horizontalRows[0].push(result.item);\n        horizontalRows[1].push(value);\n      }\n    };\n\n    for (var prop in json) {\n      var prefix = \"\";\n      if (this._options.mainPathItem) prefix = this._options.mainPathItem + this._options.headerPathString;\n      parseResult = this._handler.check(json[prop], prefix + prop, prop, json);\n      parseResult.forEach(fillRows);\n    }\n\n    if (!this._options.verticalOutput) {\n      fileRows.push(horizontalRows[0].join(this._options.rowDelimiter));\n      fileRows.push(horizontalRows[1].join(this._options.rowDelimiter));\n    }\n\n    return joinRows(fileRows, this._options.endOfLine);\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/Users/colin/Desktop/GitHub/running-app/client/node_modules/jsonexport/lib/parser/csv.js"],"names":["joinRows","require","Handler","helper","Parser","constructor","options","_options","_handler","_headers","headers","_escape","textDelimiter","rowDelimiter","forceTextDelimiter","parse","json","done","stream","isArray","_parseArray","isObject","_parseObject","Error","rename","length","map","header","indexOf","mapHeaders","join","_checkRows","rows","lastRow","finalRows","fillGaps","col","index","undefined","row","missing","concat","Array","split","push","self","fileRows","outputFile","fillRows","getHeaderIndex","result","fillAndPush","newRow","fill","emptyRowIndexByHeader","currentRow","element","elementHeaderIndex","item","fillTopRow","value","itemResult","check","mainPathItem","includeHeaders","unshift","endOfLine","parseResult","horizontalRows","toString","undefinedString","verticalOutput","prop","prefix","headerPathString","forEach","module","exports"],"mappings":"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","sourcesContent":["/* jshint node:true */\n'use strict';\n\n/**\n * Module dependencies.\n */\nconst joinRows = require('../core/join-rows');\nconst Handler = require('./handler');\nconst helper = require('../core/helper');\n\nclass Parser {\n  constructor(options) {\n    this._options = options || {};\n    this._handler = new Handler(this._options);\n    this._headers = this._options.headers || [];\n    this._escape = require('../core/escape-delimiters')(\n      this._options.textDelimiter,\n      this._options.rowDelimiter,\n      this._options.forceTextDelimiter\n    );\n  }\n\n  /**\n   * Generates a CSV file with optional headers based on the passed JSON,\n   * with can be an Object or Array.\n   *\n   * @param {Object|Array} json\n   * @param {Function} done(err,csv) - Callback function\n   *      if error, returning error in call back.\n   *      if csv is created successfully, returning csv output to callback.\n   */\n  parse(json, done, stream) {\n    if (helper.isArray(json)) return done(null, this._parseArray(json, stream));\n    else if (helper.isObject(json)) return done(null, this._parseObject(json));\n    return done(new Error('Unable to parse the JSON object, its not an Array or Object.'));\n  }\n\n  get headers() {\n    let headers = this._headers;\n\n    if (this._options.rename && this._options.rename.length > 0)\n      headers = headers.map((header) => this._options.rename[this._options.headers.indexOf(header)] || header);\n      \n    if (this._options.forceTextDelimiter) {\n      headers = headers.map((header) => {\n        return `${this._options.textDelimiter}${header}${this._options.textDelimiter}`;\n      });\n    }\n\n    if (this._options.mapHeaders)\n      headers = headers.map(this._options.mapHeaders);\n\n    return headers.join(this._options.rowDelimiter);\n  }\n\n  _checkRows(rows) {\n    let lastRow = null;\n    let finalRows = [];\n    let fillGaps = (col, index) => col === '' || col === undefined ? lastRow[index] : col;\n    for (let row of rows) {\n      let missing = this._headers.length - row.length;\n      if (missing > 0) row = row.concat(Array(missing).join(\".\").split(\".\"));\n      if (lastRow && this._options.fillGaps) row = row.map(fillGaps);\n      finalRows.push(row.join(this._options.rowDelimiter));\n      lastRow = row;\n    }\n    return finalRows;\n  }\n\n  _parseArray(json, stream) {\n    let self = this;\n    this._headers = this._headers || [];\n    let fileRows = [];\n    let outputFile;\n    let fillRows;\n\n    let getHeaderIndex = function(header) {\n      var index = self._headers.indexOf(header);\n      if (index === -1) {\n        self._headers.push(header);\n        index = self._headers.indexOf(header);\n      }\n      return index;\n    };\n\n    //Generate the csv output\n    fillRows = function(result) {\n      const rows = [];\n      const fillAndPush = (row) => rows.push(row.map(col => col != null ? col : ''));\n      // initialize the array with empty strings to handle 'unpopular' headers\n      const newRow = () => new Array(self._headers.length).fill(null);\n      const emptyRowIndexByHeader = {};\n      let currentRow = newRow();\n      for (let element of result) {\n        let elementHeaderIndex = getHeaderIndex(element.item);\n        if (currentRow[elementHeaderIndex] != undefined) {\n          fillAndPush(currentRow);\n          currentRow = newRow();\n        }\n        emptyRowIndexByHeader[elementHeaderIndex] = emptyRowIndexByHeader[elementHeaderIndex] || 0;\n        // make sure there isnt a empty row for this header\n        if (self._options.fillTopRow && emptyRowIndexByHeader[elementHeaderIndex] < rows.length) {\n          rows[emptyRowIndexByHeader[elementHeaderIndex]][elementHeaderIndex] = self._escape(element.value);\n          emptyRowIndexByHeader[elementHeaderIndex] += 1;\n          continue;\n        }\n        currentRow[elementHeaderIndex] = self._escape(element.value);\n        emptyRowIndexByHeader[elementHeaderIndex] += 1;\n      }\n      // push last row\n      if (currentRow.length > 0) {\n        fillAndPush(currentRow);\n      }\n      fileRows = fileRows.concat(self._checkRows(rows));\n    };\n    for (let item of json) {\n      //Call checkType to list all items inside this object\n      //Items are returned as a object {item: 'Prop Value, Item Name', value: 'Prop Data Value'}\n      let itemResult = self._handler.check(item, self._options.mainPathItem, item, json);\n      fillRows(itemResult);\n    }\n\n    if (!stream && self._options.includeHeaders) {\n      //Add the headers to the first line\n      fileRows.unshift(this.headers);\n    }\n\n    return joinRows(fileRows, self._options.endOfLine);\n  }\n\n  _parseObject(json) {\n    let self = this;\n    let fileRows = [];\n    let parseResult = [];\n    let outputFile;\n    let fillRows;\n    let horizontalRows = [\n      [],\n      []\n    ];\n\n    fillRows = function(result) {\n      var value = result.value ? result.value.toString() : self._options.undefinedString;\n      value = self._escape(value);\n\n      //Type header;value\n      if (self._options.verticalOutput) {\n        var row = [result.item, value];\n        fileRows.push(row.join(self._options.rowDelimiter));\n      } else {\n        horizontalRows[0].push(result.item);\n        horizontalRows[1].push(value);\n      }\n    };\n    for (var prop in json) {\n      var prefix = \"\";\n      if (this._options.mainPathItem)\n        prefix = this._options.mainPathItem + this._options.headerPathString;\n      parseResult = this._handler.check(json[prop], prefix + prop, prop, json);\n\n      parseResult.forEach(fillRows);\n    }\n    if (!this._options.verticalOutput) {\n      fileRows.push(horizontalRows[0].join(this._options.rowDelimiter));\n      fileRows.push(horizontalRows[1].join(this._options.rowDelimiter));\n    }\n    return joinRows(fileRows, this._options.endOfLine);\n  }\n}\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}